# アーキテクチャ検討・設計判断（02_system-requirements.md ベース）

## 目的
- docs/requirements/02_system-requirements.md（要件定義書）を前提に、
  **システム／アプリケーション全体のアーキテクチャ候補**を洗い出し・比較・評価する。
- 非機能要件（パフォーマンス / 可用性 / 保守性 / セキュリティ / 運用性 等）に対する
  各アーキテクチャの適合度を、**具体的な設計方針と結びつけて**明示する。
- 最終的に採用するアーキテクチャの「判断材料」を構造化し、
  ADR 作成コマンド（adr-create.md）の入力とする。

このコマンドは **「考えるフェーズ（検討・比較・評価）」のみを担い、
ADR はその結果の「正式記録」として後続フェーズで作成する** こと。

> 重要：
> - ここで扱う「アーキテクチャ候補」は **アプリケーション／システムレベル**（レイヤード、DDD Lite、マイクロサービス etc.）を指す。
> - **UI アーキテクチャ（MVC / MVP / MVVM 等）を、アプリケーションアーキテクチャ候補そのものとして比較候補に並べてはならない。**
>   - UI パターンは、各候補の中の「プレゼンテーション層の設計方針」として記述する。

---

## 入力

必ず以下のファイルを前提とすること：

- `docs/requirements/02_system-requirements.md`
- 必要に応じて：
  - `docs/requirements/01_stakeholder-needs.md`
  - 既存 ADR（既存システム拡張の場合）

追加で、ユーザーから以下のような補足を受け取ってもよい：

- 想定している技術スタックの制約（例：Python / Qt / C#.NET / DB 種別 など）
- インフラ（オンプレ / クラウド / コンテナ / サーバレス）の制約
- 将来の拡張方針（マイクロサービス化を見据えるか、マルチテナント化を想定するか 等）
- 運用形態（ローカル実行 / 社内LAN / インターネット公開 / SaaS など）

入力例：

<<<02_system-requirements の要約 or ファイルパス>>>
<<<補足情報（任意）>>>

---

## 出力

`docs/design/01_architecture-evaluation.md` を生成する。
構造は以下の **固定テンプレート** に従うこと。

**見出し構造は絶対に変更してはならない。**
（ただし、各節の「中身」はここで定義するルールに従って柔軟に書き分ける）

---

# 01. Architecture Evaluation

## 1. Context（文脈）

以下の観点を **02_system-requirements.md をベースに簡潔に要約**する：

- **システムの概要**
  - Overview / System Summary 等から、本システムが何をするものかを 2〜4 行でまとめる。
- **想定される利用シナリオ**
  - 代表的なユースケースを 3〜5 個程度の箇条書きで記載する。
  - 「誰が / いつ / どの頻度で / 何のために使うか」が分かる書き方にする。
- **技術・組織・運用上の制約の整理**
  - Constraints / Non-Functional Requirements から、
    - 言語・フレームワーク・ミドルウェア・インフラ等の **技術的制約**
    - 運用時間・利用頻度・配布形態等の **運用制約**
    - 既存システム・組織体制・スキルセット等の **組織的制約**
  を抽出し、カテゴリごとに整理する。
- **データフローの前提（重要）**
  - 外部データソース（例：CSV / JSON / API）と内部データストア（例：RDB / キャッシュ）の関係を 2〜3 行で明示する。
  - 「どれが Single Source of Truth か」「日次・随時更新の方針」を簡潔に書く。

---

## 2. Quality Attributes（品質特性）

`docs/requirements/02_system-requirements.md` の非機能要件から、
**アーキテクチャ設計で特に重視すべき品質特性**を列挙する。

- 品質特性は ISO 25010 などを参考に、Performance / Availability / Maintainability / Security / Usability / Operability / Portability / Testability 等から必要なものを選定する。
- 単なるラベルではなく、**「どの数値／条件を満たす必要があるか」まで書くこと。**

例：

| ID        | Attribute      | 説明                                                         | 関連 REQ-NF |
|-----------|----------------|--------------------------------------------------------------|------------|
| QA-001    | Performance    | 主要画面の応答時間が 3 秒以内、集計バッチが 10 分以内で完了 | REQ-NF-001 |
| QA-002    | Availability   | 平日日中 99.5% 稼働、障害時の復旧時間 1 時間以内            | REQ-NF-002 |
| QA-003    | Maintainability| 変更容易性、モジュール分離、ドキュメント整備                | REQ-NF-003 |
| ...       | ...            | ...                                                          | ...        |

> 注意：
> - 「Attribute 名」と「説明」は、後続の評価（4. Evaluation）で **設計方針と結びつける前提**で書くこと。
> - 例：Performance だけでなく「どの処理」「どの操作」に対する性能なのかを具体化する。

---

## 3. Candidate Architectures（候補アーキテクチャ）

**ここで比較するのは「アプリケーション／システムアーキテクチャ」の候補のみ。**

- 例：レイヤードアーキテクチャ、クリーンアーキテクチャ、DDD Lite、マイクロサービス、モジュラモノリス etc.
- **UI パターン（MVC / MVP / MVVM 等）を単独の「Candidate」として並べてはならない。**
  - 必要なら、各 Candidate の中で「プレゼンテーション層の方針」として記述する。

検討対象とするアーキテクチャ候補を 2〜4 個程度に絞り、
それぞれについて以下を記述する：

### 3.1 Candidate A: <アーキテクチャ名>

- **概要**
  - この候補がどのような構造を持つのかを 3〜5 行で説明する。
  - モノリス／モジュラモノリス／サービス分割方針など、構造の特徴を明示する。
- **主な構成要素**
  - 例：API サーバ、バッチ、フロントエンド、DB、メッセージキュー、キャッシュ、ジョブキュー 等。
  - **アプリケーション内のレイヤ構造（例：Presentation / Application / Domain / Infrastructure）を明確に書く。**
  - プレゼンテーション層内の UI パターン（MVC / MVP / MVVM 等）は、ここで `- Presentation: PySide6 + MVP` のように **サブ項目として記載する。**
- **採用する主な技術スタック（言語 / FW / DB / インフラ）**
  - 言語、フレームワーク、DB、インフラ（オンプレ／クラウド）、ミドルウェア等を箇条書き。
- **データフローと Single Source of Truth**
  - 外部ファイルや外部サービス → アプリケーション → データストア → UI/レポート
    の流れを 3〜5 行で説明する。
  - 「どの層が何を責務として持つか」（例：インポート処理、検証、集計）は必ず書く。

### 3.2 Candidate B: <アーキテクチャ名>

- 上記と同様の構成で記述する。
- 「Aとの違い」が分かるように、差分（例：DDD 導入の有無、サービス分割方針）を意識して書く。

（必要であれば 3.3, 3.4 を追加）

> 禁止：
> - 「Candidate B: MVC Architecture」のように、UI パターン単体を Candidate として定義しないこと。
> - MVC / MVP / MVVM などは、
>   「3.x Candidate X」の中の「Presentation 層の方針」としてのみ記述する。

---

## 4. Evaluation（評価）

### 4.1 Quality Attributes × Candidate マトリクス

各候補ごとに、2章で列挙した品質特性に対する適合度を評価する。

- 評価は原則として「◎ / ○ / △ / ×」の 4 段階。
- **必ず「どの設計要素によってそう評価しているのか」をコメントに書くこと。**
  単なる印象ではなく、レイヤ構造、依存関係、データフロー、UIスレッドモデル等との紐付けを書く。

例：

| QA \ Candidate | A（Layered Monolith） | B（DDD Lite Monolith） | コメント（重要な理由・具体策） |
|----------------|------------------------|-------------------------|----------------------------------|
| QA-001         | ◎                      | ○                       | Aは処理経路が短く、インフラも単純。Bは抽象化層が1段増えるが、I/O主体で影響は小さい。 |
| QA-003         | ○                      | ◎                       | BはDomain層を独立させ、リポジトリ経由に限定するため変更影響範囲を狭く保てる。Aは層分離のみでルールが緩いと散らばりやすい。 |
| ...            | ...                    | ...                     | ...                              |

> 重要：
> - コメントは「どのレイヤ／どのコンポーネント／どの設計ルール」により QA を満たすか、
>   1〜2 行で必ず書くこと（抽象的NG）。
> - UIのレスポンス性（フリーズ対策）などは、Performance / Usability の評価時に
>   「ワーカースレッドを用いる」「進捗表示を行う」など具体策を示す。

### 4.2 リスクとトレードオフ

各候補ごとに、主要なリスクとトレードオフを整理する。

#### Candidate A
- **強み**
  - …
- **弱み / リスク**
  - …
- **向いているケース / 向いていないケース**
  - …
- **将来の機能拡張シナリオに対する見通し**
  - 要件凍結として扱っている場合でも、「どのような拡張要求が来たら再評価が必要になるか」を 1〜2 行で書く。

#### Candidate B
- 同様に記述。

> ポイント：
> - 「小規模だから大丈夫」といった楽観的な前提に逃げず、
>   将来の典型的な拡張（機能追加／外部サービス増加／組織変更）に対する見通しを書くこと。
> - データフロー・DBスキーマ・サービス分割など、
>   どこが将来のボトルネック／負債になり得るかをはっきり書く。

---

## 5. Recommended Architecture（推奨アーキテクチャ）

### 5.1 採用するアーキテクチャ

- 採用候補：Candidate <X>（<名前>）
- 採用理由（箇条書き）：
  - **主要品質特性（QA-xxx）に対する適合性**が最も高い／バランスがよいこと
  - **既存システム / チームスキルとの整合性**（現実に実装・運用できるか）
  - **将来の拡張性**（どのレベルまでなら大きなリファクタリングなしに対応できるか）
  - **データフローと Single Source of Truth** の観点で、一貫性を保ちやすいこと
  - UIアーキテクチャの方針（MVC/MVP等）が、選択したアプリケーションアーキテクチャと整合していること

### 5.2 選択しなかった候補と理由

- Candidate Y を採用しない理由
  - 長所
  - それでも優先度が下がる理由（複雑性、コスト、過剰設計、チームスキルとのギャップ 等）
- ADR では、ここで書いた内容を凝縮して「Alternatives」に載せる。

> 注意：
> - 「UIがそんなに複雑ではないので MVC を採用しない」といった表現は
>   **UIパターンの採否**として書く場合にのみ使用し、
>   アプリケーションアーキテクチャの比較理由としては使わないこと。

---

## 6. Impact & Risks（影響とリスク）

以下の観点を必ず含める：

- **開発コストへの影響**
  - 初期実装コスト（学習コスト、ボイラープレートの量）
  - テスト設計・テスト自動化のコスト
- **運用コストへの影響**
  - インフラ構成の複雑さ（モノリス vs 分散）
  - 障害対応の難易度
  - ログ収集・監視・バックアップの仕組み
- **組織・プロセスへの影響**
  - チームサイズと役割分担（フロント / バック / APP / INFRA）
  - 必要となるスキルセット
  - 既存プロセス（リリースフロー、運用手順）との整合
- **技術的負債になりうるポイント**
  - ビジネスロジックの散在（UI・Infrastructure への漏れ）
  - 層間の密結合（特に Application ↔ Infrastructure）
  - データフローが曖昧な部分（CSV vs DB の整合性など）
- **リスク軽減策の概要**
  - コーディング規約／レイヤ間の依存ルールの明文化
  - リポジトリパターンやインターフェースによる抽象化の導入
  - 定期的なアーキテクチャレビュー
  - 「どのような変更要求が来たらアーキテクチャの再評価を行うか」のトリガー定義

---

## 7. Inputs for ADR（ADR 作成のための要約）

ADR コマンド（adr-create.md）に渡すための **要約情報** を記載する。

> ここは「設計書のダンプ」ではなく、ADR向けに**圧縮したサマリ**を書くこと。
> 各項目は 3〜6 行程度を目安とする。

- **Problem（問題）**
  - どのような要求・制約・前提（技術／運用／組織／データフロー）のもとで
    アーキテクチャを決める必要があるかを簡潔にまとめる。
- **Decision（決定）**
  - 採用するアーキテクチャ（Candidate X, 名前）と、その一文要約。
  - 例：「モジュラモノリス構成のレイヤードアーキテクチャを採用し、Presentation / Application / Domain / Infrastructure の4層で構成する」など。
- **Alternatives（代替案）**
  - 検討した候補と、採用しなかった理由を箇条書きで要約。
  - ここでは詳細ではなく「なぜ退けたか」が一目で分かるレベルに抑える。
- **Rationale（根拠）**
  - 選択したアーキテクチャが最も合理的と判断された理由を、
    主要な品質特性（QA-xxx）との関係で 3〜5 行程度にまとめる。
- **Consequences（結果・影響）**
  - ポジティブ / ネガティブ両面の影響を簡潔に列挙。
  - 特に、将来の拡張時に必要となるリファクタリングや見直しポイントも含める。

`adr-create.md` では、この 7 章の内容をそのまま ADR の各セクションに流用してよいが、
必要に応じてさらに凝縮・整形すること。

---

## 禁止事項

- `docs/requirements/02_system-requirements.md` の内容や構造を勝手に変更しないこと。
- STK / REQ-F / REQ-NF の ID を再定義・再採番しないこと。
- 「アーキテクチャ検討」と「最終決定（ADR）」を混同しないこと。
  本ドキュメントは **検討結果の記録** にとどめ、
  最終決定は ADR で行う前提とする。
- **UI アーキテクチャ（MVC / MVP / MVVM 等）を、アプリケーションアーキテクチャ候補そのものとして Candidate に並べないこと。**
  必要であれば、「各 Candidate の中の Presentation 層の設計方針」としてのみ扱う。
