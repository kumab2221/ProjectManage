# 1. プロジェクト作成（Claude Code 前提）

## 1.1 目的
- Claude Code と MCP（Context7 / filesystem / git / exec / text-analysis）を前提にした開発プロジェクトの初期セットアップを標準化する。
- どのプロジェクトでも本章の手順を完了すれば、後続フェーズ（要件定義 → 設計 → ADR → 実装 → テスト）を再現性と品質を維持しながら進められる状態にする。

---

## 1.2 手順概要

1. プロジェクトディレクトリの作成  
2. Python 仮想環境（uv）＋ 基本品質ツール（ruff / mypy / pytest）の導入  
3. Git 初期化（main ブランチを確定）  
4. ベースディレクトリ構成の作成＋ src-layout への統一  
5. Claude Code 初期化  
6. ベース MCP の追加（Context7 / filesystem / git / exec / text-analysis）  
7. Claude.md（プロジェクト記憶）の作成  
8. カスタムコマンド（`.claude/commands/*.md`）の作成  

---

## 1.3 プロジェクトディレクトリ作成

```sh
mkdir <project>
cd <project>
```

- `<project>` はリポジトリ名・Claude Code の Project name と一致させる。

---

## 1.4 仮想環境の追加（Python / uv）

本プロジェクトでは **src-layout（src/ 配下にコードを配置）** を必須とするため、  
uv init が生成する main.py は後で移動する。

```sh
uv init .
uv add --dev ruff mypy pytest lizard
```

- `uv init .` で `pyproject.toml` と仮想環境を作成する。
- `ruff` と `mypy` は標準の品質チェックツールとして必須とする。

### なぜ pytest をこの段階で入れるのか？
- **TDD / BDD を初期から可能にするため**
- CI/CD 構成（GitHub Actions / Jenkins）と整合性が取れるため
- Claude Code の `implement-file.md` でテスト自動生成を行うため

---

## 1.5 Git 初期化

```sh
git init .
git branch -M main
```

- `.gitignore` は uv + Python 専用の推奨設定を使用する。
- main ブランチは常に「動作保証状態」とし、CI/CD はこの前提で構成する。

---

## 1.6 ベースディレクトリ構成

（src-layout + ドキュメントテンプレ構造と完全整合）
uv init により `main.py` がプロジェクト直下に生成されるため、**src-layout** に統一する。

```sh
mkdir -p src tests
mkdir -p docs/requirements docs/design
mkdir -p ADR
mkdir -p plans
mkdir -p docs/release-notes
mkdir -p .github/workflows
mkdir -p .claude/commands

mv main.py src/main.py
```

### なぜ src-layout が必須なのか？
- Python の推奨構造（PyPA 標準）
- CI（pytest / ruff / mypy）が安定する
- Claude Code がファイル参照する際のパスブレを防止
- 将来的なパッケージ化にも対応可能
- テストと実装のディレクトリを明確にセパレートするため

### ディレクトリごとの役割（後工程との整合性を明記）

| ディレクトリ | 役割 |
|--------------|------|
| src/ | アプリケーション本体（すべてのコードはここに置く） |
| tests/ | pytest による自動テスト群 |
| docs/requirements/ | 01, 02, 03, 04 の要求/要件/文脈テンプレ文書 |
| docs/design/ | 設計書（UI/ドメイン/インターフェース） |
| ADR/ | Architecture Decision Record（設計判断の履歴） |
| plans/ | 機能別実装計画（フィーチャー分解） |
| docs/release-notes/ | リリースノート自動生成の保管場所 |
| .github/workflows/ | GitHub Actions（CI/CD） |
| .claude/commands/ | Claude Code のカスタムコマンド定義 |

### 注意（見出し構造保護との整合性）
docs/requirements の文書（01, 02）は  
**Claude.md により見出し構造固定を強制できる前提**  
で運営される。

---

## 1.7 Claude Code 初期化

Claude Code 上で当該プロジェクトを開き、以下を実行する。

```claude
/init
```

### この工程の目的
- この瞬間から、このディレクトリが **Claude Code にとっての正式な “Project context”** になる。
- 以降の会話・生成物はすべて **Project memory（Claude.md）に基づく** 振る舞いに変わる。
- Claude がプロジェクト単位で「仕様 → 設計 → ADR → コード → テスト」を一貫処理できる環境がここで初期化される。

### 注意（絶対遵守）
- `/init` 前にファイル生成を依頼すると、Claude が文脈を誤認してテンプレ構造が壊れる可能性がある。
- `/init` は **MCP 導入より先に実行する**。  
  （MCP がプロジェクトに紐づかない不整合を防止）

---

## 1.8 MCP 標準構成（Claude Code プロジェクト用）  
（Context7 / filesystem  — scope=project）

### 1.8.1 目的

本プロジェクトの開発フロー（要件 → 設計 → ADR → 実装 → テスト）において、Claude Code が次の 2 つの能力を持つことを保証する：

| MCP 名（Claude 内名称） | パッケージ名（公式）                                  | 目的 |
|------------------------|------------------------------------------------------|------|
| filesystem             | @modelcontextprotocol/server-filesystem              | ファイル操作（生成・更新・削除・探索） |
| context7               | @upstash/context7-mcp                                | ドキュメント/API仕様参照（Upstash） |

※ modelcontextprotocol/* は MCP 公式 Reference Server。  
※ context7 は Upstash が提供する唯一の “AI対応ドキュメントレイヤ MCP” のため例外採用。


---

### 1.8.2 スコープと前提（ここを間違えると全て壊れる）

Claude CLI の `-s` / `--scope` は **「スコープ指定」** であり、  
**プロジェクト名ではない**。

利用可能なスコープは以下のみ：

- `local`
- `user`
- `project`
- `dynamic`
- `enterprise`

本プロジェクトでは、  
**「このリポジトリ専用の MCP 構成」** を作るため、  
すべて **`-s project`（project scope）** で登録する。

> `-s profit_trace` のように **任意の文字列を指定することはできない**。  
> `Invalid scope: xxx` エラーになるのは仕様通り。

---

### 1.8.3 MCP 追加手順（必須 2 種）

Claude Code は OS によって MCP サーバを起動する方法が異なる。  
特に **Windows 版 Claude Code は `npx` を直接呼び出せない仕様**のため、  
`cmd /c` を前置して **必ず cmd.exe 経由で npx を起動させる必要がある**。

| OS | npx 実行可否 | 必要な対処 | 例 |
|----|--------------|------------|-----|
| **Windows** | ✗（Claude Code では直接不可） | `cmd /c` を前置する | `cmd /c npx @modelcontextprotocol/server-filesystem` |
| **Linux / macOS** | ○（そのまま動作） | 対処不要 | `npx @modelcontextprotocol/server-filesystem` |

---

#### 共通構文

```sh
claude mcp add <name> -s project -- <commandOrUrl>
```

- `<name>`: Claude から見える MCP 名（例: `context7`, `filesystem` など）
- `-s project`: 「このプロジェクト用の MCP」として登録する
- `<commandOrUrl>`: MCP サーバを起動するためのコマンド or URL  
  （各 MCP ごとに異なる。公式 README の指示に従うこと）

---

#### 1.8.3.1 Context7 MCP（ドキュメント参照）

#### Linux / macOS

```sh
claude mcp add context7 -s project -- npx @upstash/context7-mcp --api-key YOUR_API_KEY
```

#### Windows
Windowsの場合は`--api-key`を認識しないので、まずは下記を記載し、直接.mcp.jsonファイルを編集する

```sh
claude mcp add context7 -s project -- cmd /c npx @upstash/context7-mcp
```
[https://context7.com/](https://context7.com/)からAPI KEYを取得する
```json
"context7": {
      "type": "stdio",
      "command": "cmd",
      "args": [
        "/c",
        "npx",
        "@upstash/context7-mcp",
        "--api-key",
        "XXXXX"
      ],
      "env": {}
    }
```

用途：
- Python / Node / Rust / C# など公式ドキュメント参照  
- API 仕様の正確な参照  
- 設計判断の精度向上  
- ADR の合理性裏付け

---

#### 1.8.3.2 filesystem MCP（ファイル操作）

#### Linux / macOS

```sh
claude mcp add filesystem -s project -- npx @modelcontextprotocol/server-filesystem
```

#### Windows  
（実際に失敗していた部分。原因は Windows 版 Claude Code では npx が直接動かないため）

```sh
claude mcp add filesystem -s project -- cmd /c npx @modelcontextprotocol/server-filesystem
```

用途：
- `docs/requirements/` や `docs/design/`、`ADR/` のファイル自動生成
- `src/` のコード生成・更新
- 差分パッチ適用

---

### 1.8.4 MCP 設定確認（必須）

```sh
claude mcp list
```

以下 2 種が揃っていれば正しく導入されている：

- context7
- filesystem

1 つでも欠けていれば、該当 MCP の `<commandOrUrl>` 指定が誤っている可能性が高い。

---

### 1.8.5 MCP 導入後の初期動作チェック

#### filesystem の動作確認

```claude
docs/requirements/test.md を作成し、
内容を「MCP OK」という 1 行だけにしてください。
```

#### context7 の動作確認

```claude
Python の requests ライブラリの最新仕様を context7 で参照し、
要点を箇条書きでまとめてください。use context7
```

---

### 1.8.6 MCP フェーズの終了条件

以下の条件をすべて満たした場合、このフェーズを完了とする：

- `claude mcp list` に 2 種（context7 / filesystem ）が表示されている
- 各 MCP で最低 1 回の操作（ファイル操作 / 仕様参照）が成功している
- Claude Code が  
  「要件整理 → 要件定義 → 設計 → ADR → 実装 → テスト」  
  を実行可能な最低限の基盤を満たしている

---

## 1.9 ベースメモリ（Claude.md）作成

プロジェクトの前提・ルール・構造をまとめた `Claude.md` をプロジェクトルートに作成する。

テンプレート例：

````markdown
# Project memory

このファイルは Claude Code の振る舞いを制御するための **プロジェクト仕様** である。  
本プロジェクトにおいて Claude は、ここに定められた規則を常に守らなければならない。

---

# 1. Project Overview
- Project name: <project>
- Purpose: <1〜3行>
- Primary language: Python (uv)
- Entrypoint: src/main.py

---

# 2. Document Templates (Structural Integrity Rules)

以下のドキュメントは **見出し構造が完全固定** であり、  
Claude は、**追記以外の変更（削除 / 並び替え / 統合 / 分解 / 改名）を一切行ってはならない**。

## 2.1 01_stakeholder-needs.md の構造（固定）
```
# 01. Stakeholder Needs
## 1. Purpose
## 2. Scope
### 2.1 In Scope
### 2.2 Out of Scope
## 3. Stakeholder List
## 4. Stakeholder Needs
### 4.x <Stakeholder Name>
#### STK-xxx: <Title>
## 5. Constraints
## 6. Assumptions
## 7. Open Questions
## 8. Appendix
```

## 2.2 02_system-requirements.md の構造（固定）
```
# 02. System Requirements
## 1. Overview
## 2. Definitions
## 3. Functional Requirements
### 3.1 構成方針
### 3.2 要件一覧
#### REQ-F-xxx: <Title>
## 4. Non-Functional Requirements
#### REQ-NF-xxx: <Title>
## 5. Constraints
## 6. Open Questions
## 7. Appendix
```

### 【重要】
Claude がこれらに触れるときは、  
**・追記は許可  
・既存見出しの削除は禁止  
・既存見出しの名称変更は禁止  
・既存見出しの階層変更は禁止  
・新しい章の追加は禁止（Appendix 内は可）  
・内容の書き換えは Claude が明確な理由（要件反映）がある場合のみ許可**  
とする。

---

# 3. Repository Layout
- src/
- tests/
- docs/requirements/
- docs/design/
- ADR/
- plans/
- docs/release-notes/

---

# 4. Process Rules
- 開発フロー：要件 → 設計 → ADR → 実装 → テスト
- 要件・設計の前に、必ず docs/requirements を参照する
- 重要な判断は必ず ADR に記録する
- main ブランチは常に動作保証状態とする

---

# 5. Claude Usage Policy (行動規範)

Claude は以下の行動規範に従う。

## 5.1 テンプレ遵守ルール（最重要）
- 固定テンプレ構造を **絶対に変更してはならない**
- 見出し構造を “省略して要約” する行為も禁止
- 「別の構造のほうがよい」などの提案は Appendix へ書くが、構造自体は変えない
- 要件追加は **既存の適切な見出しの下に追記** のみ許可

## 5.2 ドキュメント編集ルール
- 編集前に該当 doc の全文を読み込む
- 差分パッチ形式での変更を優先する
- 変更理由を説明する（例：STK-xxx との整合性）

## 5.3 技術ドキュメントの一貫性
- STK-xxx → REQ-F/REQ-NF のトレーサビリティを維持する  
- 不確実性は Open Questions に送る（埋めない）

---

# 6. MCP Usage Rules
- context7：公式ドキュメント参照に使用  
- filesystem：Markdown ドキュメントの自動編集  
---

# 7. 禁止事項
Claude は **以下の行為を禁止** される。

- ドキュメント構造（見出し）の変更  
- 章タイトルの変更  
- 階層構造の変更  
- 分割/統合による章の再構成  
- 任意の新章追加（Appendix 以外）  
- テンプレの自動要約や省略  

---

# 8. Development Principles
- 情報不足は “補完しない”。Open Questions に送る。
- 数値の省略禁止（例：「高速」→ “500ms 以下” 提案）
- 曖昧表現禁止

---

# 9. Appendix
必要なら補足を追加する。
````

---

## 1.10 カスタムコマンド追加（`.claude/commands`）

### 1.10.1 目的

- Claude Code のコマンドパレットから、頻出の作業（要件整理・設計生成・プラン作成・実装・品質チェック・リリースノート作成・CI設定）を一貫した形で呼び出せるようにする。
- チーム全体で同じプロンプト・同じフローを共有し、再現性のある開発プロセスを確立する。

---

### 1.10.2 カスタムコマンド作成方法

カスタムコマンドは **`.claude/commands/*.md`** として保存する。

作成依頼例：

```claude
要求整理テンプレートを
.claude/commands/requirements-draft.md に作成してください。
```

Claude 再起動後、`requirements-draft` コマンドとして利用可能になる。

---

### 1.10.3 ベースコマンド一覧

初期セットアップで、少なくとも以下のコマンドを用意する。

#### 必須（要件〜実装〜品質）

1. `requirements-draft.md`
   - ヒアリングメモ → `docs/requirements/01_stakeholder-needs.md` のドラフト生成。

   ```markdown
   # 要求整理（ヒアリングメモ → 01_stakeholder-needs.md）

   以下のヒアリングメモを、固定テンプレート構造にマッピングし
   docs/requirements/01_stakeholder-needs.md を生成すること。

   **見出し構造は絶対に変更してはならない。**

   ---

   ## 【出力するファイル構造】

   # 01. Stakeholder Needs

   ## 1. Purpose
   （ヒアリング内容から目的を抽出し、1〜3 行で要約する）

   ## 2. Scope
   ### 2.1 In Scope
   （対象とする範囲を列挙する）
   ### 2.2 Out of Scope
   （対象外の範囲があれば補完する）

   ## 3. Stakeholder List
   | ID | Stakeholder | 役割 / 関心事 |
   |----|-------------|----------------|
   （ヒアリング内容から抽出し、STKH-xxx として列挙）

   ## 4. Stakeholder Needs
   ステークホルダー単位で要求を分類し、以下の構造に従って必ず記述する。

   ### 4.x <Stakeholder Name>
   #### STK-xxx: <要求タイトル>
   **概要**
   （要求の要点を 1 行で要約）

   **詳細**
   - ユースケース
   - 背景
   - 懸念・不満点
   - 必要とされる理由
   （メモに足りない場合は質問として Open Questions に送る）

   **受入条件**
   - 条件1
   - 条件2

   **関連ステークホルダー**
   - STKH-xxx

   **優先度**
   MUST / SHOULD / COULD / WON'T より選択

   ## 5. Constraints
   - 技術的制約
   - 運用制約
   - 外部依存
   （ヒアリングに無い場合は空欄ではなく "情報不足、要確認" と記述）

   ## 6. Assumptions
   （前提条件を抽出し、不足がある場合は "要確認（理由）" と明記）

   ## 7. Open Questions
   不明点や曖昧な部分を必ずここに列挙すること。
   - 質問内容
   - 誰に確認すべきか
   - 影響範囲

   ## 8. Appendix
   - 元ヒアリングメモ要約
   - 関連図や補足があれば記載

   ---

   ## 【入力】
   <<<ヒアリングメモ>>>
   ```

2. `requirements-refine.md`
   - `01_stakeholder-needs.md`の質問を解消

   ```markdown
   # 要求クリーニング（Open Questions 解消 → 01_stakeholder-needs.md 更新）

   ## 目的
   - docs/requirements/01_stakeholder-needs.md の **7. Open Questions** を解消し、
     要求を完成状態（凍結）にする。
   - 既存テンプレート構造を絶対に変更しない。
   - 解消された質問内容は、対応するセクション（Purpose / Scope / Needs / Constraints など）に反映させる。

   ---

   ## 入力
   - 回答したい Open Questions の一覧
   - 回答内容（ユーザーが入力）

   例:
   <<<OpenQuestions回答>>>

   ---

   ## 出力要件

   1. docs/requirements/01_stakeholder-needs.md を再生成する。
   2. 見出し構造は **以下の固定構造を絶対に変更しない**

     - # 01. Stakeholder Needs
     - 1. Purpose
     - 2. Scope
       - 2.1 In Scope
       - 2.2 Out of Scope
     - 3. Stakeholder List
     - 4. Stakeholder Needs
     - 5. Constraints
     - 6. Assumptions
     - 7. Open Questions
     - 8. Appendix

   3. 質問に回答された箇所は適切なセクションに反映する。
   4. 解消された Open Questions は削除する。
   5. まだ不足があれば、新たな Open Questions を追加する。
   6. すべての質問が解消された場合、7 は `None` のみとする。

   ---

   ## 禁止事項
   - 見出し構造の追加・削除・並び替え
   - 01_stakeholder-needs.md に存在しない要素の追加
   - STK-ID や STKH-ID の再採番
   ```


3. `requirements-definition.md`
   - ステークホルダー要求 → `docs/requirements/02_system-requirements.md` の要件定義書生成。

   ```markdown
   # 要件定義生成（01_stakeholder-needs.md → 02_system-requirements.md）

   docs/requirements/01_stakeholder-needs.md を参照し、
   以下に示す **完全固定テンプレート構造** に基づいて
   docs/requirements/02_system-requirements.md を生成すること。

   **見出し構造は絶対に変更してはならない。**

   あいまい・不足・矛盾がある場合は
   「6. Open Questions」で必ず指摘し、埋めようとしないこと。

   ---

   ## 【出力するファイル構造】

   # 02. System Requirements

   ## 1. Overview（概要）
   - システムの目的
   - 01_stakeholder-needs.md の Purpose との整合性を確認して要約
   - システムが何を解決するかを 3〜5 行でまとめる

   ---

   ## 2. Definitions（定義）
   要求から登場する重要語句を整理し、
   用語集（03_glossary.md）で定義する前の仮リストとして記述する。

   | Term | Definition | Related Requirements |
   |------|------------|----------------------|
   | <用語> | <定義> | STK-xxx |

   ---

   ## 3. Functional Requirements（機能要件）

   ### 3.1 構成方針
   - 要求（STK-xxx）から導出される機能要件を
     **REQ-F-XXX（機能ID）** 形式で記述すること。
   - 各要件は **受入条件** を必ず持つ。
   - 必ず **関連するステークホルダー要求（STK-xxx）** と紐付ける。

   ---

   ### 3.2 要件一覧

   #### REQ-F-xxx: <機能要件タイトル>
   **概要**
   要求から導出した機能の要点（1 行）

   **詳細**
   - システムが実行すべき動作
   - 入力 / 出力
   - 例外処理（可能な範囲）
   - 条件分岐に必要な情報

   **受入条件（明確な検証可能条件）**
   - 条件1
   - 条件2

   **関連要求**
   - STK-xxx, STK-yyy

   **備考（必要なら）**
   （仕様で補足が必要な点）

   ---

   ## 4. Non-Functional Requirements（非機能要件）

   非機能要件は **REQ-NF-XXX** の形式で記述する。

   ### 4.1 パフォーマンス（例）
   #### REQ-NF-001: <タイトル>
   - 詳細
   - 数値基準（曖昧な場合は提案を行う）

   ### 4.2 セキュリティ
   （同形式）

   ### 4.3 保守性
   （同形式）

   ### 4.4 運用性
   （同形式）

   ### 4.5 可用性
   （同形式）

   ※ 非機能要件カテゴリは必要に応じて追加してよいが、
     **REQ-NF の ID体系は必ず統一すること。**

   ---

   ## 5. Constraints（制約）
   01_stakeholder-needs.md の Constraints を以下に継承し、不足があれば補完する。

   - <制約1>
   - <制約2>

   曖昧なものがあれば **"情報不足（理由）"** と明記する。

   ---

   ## 6. Open Questions（要確認事項）
   要求から要件化できなかった曖昧点や不足情報は
   必ずここにまとめて列挙する。

   | 質問 | 理由 / 影響範囲 | 誰に確認すべきか |
   |------|----------------|-------------------|
   | <例> この機能は管理者だけか？ | 認可要件に影響 | PO |

   要件定義フェーズを進める前に解消すべき点をクリアにする。

   ---

   ## 7. Appendix
   - 要求 → 要件のマッピング表（Claude が自動生成してよい）
   - メモ・補足

   ---

   ## 【入力】
   docs/requirements/01_stakeholder-needs.md の内容全体を参照すること。
   必要であれば context7 を利用して関連ドキュメントを参照してよい。
   ```

4. `requirements-definition-refine.md`
   - 02_system-requirements.md の Open Questions を解消する専用コマンド

   ```markdown
   # 要件定義クリーニング（Open Questions 解消 → 02_system-requirements.md 更新）

   ## 目的
   - docs/requirements/02_system-requirements.md の **6. Open Questions** を解消し、
     要件定義書を完成状態（凍結）にする。
   - **完全固定テンプレート構造を絶対に変更しない。**
   - 回答内容は、対応するセクション（Functional / Non-Functional / Constraints など）に正しく反映させる。
   - 解消不能な質問が残る場合は、Open Questions に残すが、理由と影響範囲を明確化する。

   ---

   ## 入力
   - 回答したい Open Questions の一覧
   - 回答内容（ユーザーが入力）

   例:
   <<<OpenQuestions回答>>>

   ---

   ## 出力要件

   1. docs/requirements/02_system-requirements.md を **テンプレート構造そのまま** で再生成する。

   2. **見出し構造を絶対に変更してはならない**

     - # 02. System Requirements
     - 1. Overview
     - 2. Definitions
     - 3. Functional Requirements
       - 3.1 構成方針
       - 3.2 要件一覧（REQ-F-xxx）
     - 4. Non-Functional Requirements
     - 5. Constraints
     - 6. Open Questions
     - 7. Appendix

   3. 回答済みの質問は、該当する要件へ内容を反映させる
     - 機能要件：REQ-F-xxx
     - 非機能要件：REQ-NF-xxx
     - 制約：5. Constraints
     - Definitions に追加が必要なら反映

   4. **解消された Open Questions は削除する**。

   5. **新たな曖昧点が見つかった場合は、新しい Open Questions を追加する**。

   6. **Open Questions が完全解消された場合**：
     - `6. Open Questions` セクションは `"None"` のみ記載する。

   ---

   ## 禁止事項
   - 見出し構造の追加・削除・改変
   - 02_system-requirements.md に存在しない項目の追加
   - REQ-F / REQ-NF の ID を再採番すること
   - 機能要件の構造崩壊（概要/詳細/受入条件などの欠落）

   ---

   ## 注意
   - constraints との整合性が失われる場合、Claude に必ず指摘させる。
   - refactor ではなく **要件の純粋なクリーニング** のみに用途を限定する。
   ```
5. `architecture-decision.md`
  - 02_system-requirements.md を前提に、アーキテクチャ候補を洗い出し・比較し、ADR 作成のインプットとなる「アーキテクチャ検討結果ドキュメント」を生成する。

  ```markdown
  # アーキテクチャ検討・設計判断（02_system-requirements.md ベース）

  ## 目的
  - docs/requirements/02_system-requirements.md（要件定義書）を前提に、
    **システム／アプリケーション全体のアーキテクチャ候補**を洗い出し・比較・評価する。
  - 非機能要件（パフォーマンス / 可用性 / 保守性 / セキュリティ / 運用性 等）に対する
    各アーキテクチャの適合度を、**具体的な設計方針と結びつけて**明示する。
  - 最終的に採用するアーキテクチャの「判断材料」を構造化し、
    ADR 作成コマンド（adr-create.md）の入力とする。

  このコマンドは **「考えるフェーズ（検討・比較・評価）」のみを担い、  
  ADR はその結果の「正式記録」として後続フェーズで作成する** こと。

  > 重要：
  > - ここで扱う「アーキテクチャ候補」は **アプリケーション／システムレベル**（レイヤード、DDD Lite、マイクロサービス etc.）を指す。
  > - **UI アーキテクチャ（MVC / MVP / MVVM 等）を、アプリケーションアーキテクチャ候補そのものとして比較候補に並べてはならない。**
  >   - UI パターンは、各候補の中の「プレゼンテーション層の設計方針」として記述する。

  ---

  ## 入力

  必ず以下のファイルを前提とすること：

  - `docs/requirements/02_system-requirements.md`
  - 必要に応じて：
    - `docs/requirements/01_stakeholder-needs.md`
    - 既存 ADR（既存システム拡張の場合）

  追加で、ユーザーから以下のような補足を受け取ってもよい：

  - 想定している技術スタックの制約（例：Python / Qt / C#.NET / DB 種別 など）
  - インフラ（オンプレ / クラウド / コンテナ / サーバレス）の制約
  - 将来の拡張方針（マイクロサービス化を見据えるか、マルチテナント化を想定するか 等）
  - 運用形態（ローカル実行 / 社内LAN / インターネット公開 / SaaS など）

  入力例：

  <<<02_system-requirements の要約 or ファイルパス>>>  
  <<<補足情報（任意）>>>

  ---

  ## 出力

  `docs/design/01_architecture-evaluation.md` を生成する。  
  構造は以下の **固定テンプレート** に従うこと。

  **見出し構造は絶対に変更してはならない。**  
  （ただし、各節の「中身」はここで定義するルールに従って柔軟に書き分ける）

  ---

  # 01. Architecture Evaluation

  ## 1. Context（文脈）

  以下の観点を **02_system-requirements.md をベースに簡潔に要約**する：

  - **システムの概要**  
    - Overview / System Summary 等から、本システムが何をするものかを 2〜4 行でまとめる。
  - **想定される利用シナリオ**  
    - 代表的なユースケースを 3〜5 個程度の箇条書きで記載する。
    - 「誰が / いつ / どの頻度で / 何のために使うか」が分かる書き方にする。
  - **技術・組織・運用上の制約の整理**  
    - Constraints / Non-Functional Requirements から、
      - 言語・フレームワーク・ミドルウェア・インフラ等の **技術的制約**
      - 運用時間・利用頻度・配布形態等の **運用制約**
      - 既存システム・組織体制・スキルセット等の **組織的制約**
    を抽出し、カテゴリごとに整理する。
  - **データフローの前提（重要）**
    - 外部データソース（例：CSV / JSON / API）と内部データストア（例：RDB / キャッシュ）の関係を 2〜3 行で明示する。
    - 「どれが Single Source of Truth か」「日次・随時更新の方針」を簡潔に書く。

  ---

  ## 2. Quality Attributes（品質特性）

  `docs/requirements/02_system-requirements.md` の非機能要件から、  
  **アーキテクチャ設計で特に重視すべき品質特性**を列挙する。

  - 品質特性は ISO 25010 などを参考に、Performance / Availability / Maintainability / Security / Usability / Operability / Portability / Testability 等から必要なものを選定する。
  - 単なるラベルではなく、**「どの数値／条件を満たす必要があるか」まで書くこと。**

  例：

  | ID        | Attribute      | 説明                                                         | 関連 REQ-NF |
  |-----------|----------------|--------------------------------------------------------------|------------|
  | QA-001    | Performance    | 主要画面の応答時間が 3 秒以内、集計バッチが 10 分以内で完了 | REQ-NF-001 |
  | QA-002    | Availability   | 平日日中 99.5% 稼働、障害時の復旧時間 1 時間以内            | REQ-NF-002 |
  | QA-003    | Maintainability| 変更容易性、モジュール分離、ドキュメント整備                | REQ-NF-003 |
  | ...       | ...            | ...                                                          | ...        |

  > 注意：
  > - 「Attribute 名」と「説明」は、後続の評価（4. Evaluation）で **設計方針と結びつける前提**で書くこと。
  > - 例：Performance だけでなく「どの処理」「どの操作」に対する性能なのかを具体化する。

  ---

  ## 3. Candidate Architectures（候補アーキテクチャ）

  **ここで比較するのは「アプリケーション／システムアーキテクチャ」の候補のみ。**

  - 例：レイヤードアーキテクチャ、クリーンアーキテクチャ、DDD Lite、マイクロサービス、モジュラモノリス etc.
  - **UI パターン（MVC / MVP / MVVM 等）を単独の「Candidate」として並べてはならない。**
    - 必要なら、各 Candidate の中で「プレゼンテーション層の方針」として記述する。

  検討対象とするアーキテクチャ候補を 2〜4 個程度に絞り、  
  それぞれについて以下を記述する：

  ### 3.1 Candidate A: <アーキテクチャ名>

  - **概要**  
    - この候補がどのような構造を持つのかを 3〜5 行で説明する。
    - モノリス／モジュラモノリス／サービス分割方針など、構造の特徴を明示する。
  - **主な構成要素**  
    - 例：API サーバ、バッチ、フロントエンド、DB、メッセージキュー、キャッシュ、ジョブキュー 等。
    - **アプリケーション内のレイヤ構造（例：Presentation / Application / Domain / Infrastructure）を明確に書く。**
    - プレゼンテーション層内の UI パターン（MVC / MVP / MVVM 等）は、ここで `- Presentation: PySide6 + MVP` のように **サブ項目として記載する。**
  - **採用する主な技術スタック（言語 / FW / DB / インフラ）**  
    - 言語、フレームワーク、DB、インフラ（オンプレ／クラウド）、ミドルウェア等を箇条書き。
  - **データフローと Single Source of Truth**  
    - 外部ファイルや外部サービス → アプリケーション → データストア → UI/レポート  
      の流れを 3〜5 行で説明する。
    - 「どの層が何を責務として持つか」（例：インポート処理、検証、集計）は必ず書く。

  ### 3.2 Candidate B: <アーキテクチャ名>

  - 上記と同様の構成で記述する。
  - 「Aとの違い」が分かるように、差分（例：DDD 導入の有無、サービス分割方針）を意識して書く。

  （必要であれば 3.3, 3.4 を追加）

  > 禁止：
  > - 「Candidate B: MVC Architecture」のように、UI パターン単体を Candidate として定義しないこと。
  > - MVC / MVP / MVVM などは、  
  >   「3.x Candidate X」の中の「Presentation 層の方針」としてのみ記述する。

  ---

  ## 4. Evaluation（評価）

  ### 4.1 Quality Attributes × Candidate マトリクス

  各候補ごとに、2章で列挙した品質特性に対する適合度を評価する。

  - 評価は原則として「◎ / ○ / △ / ×」の 4 段階。
  - **必ず「どの設計要素によってそう評価しているのか」をコメントに書くこと。**  
    単なる印象ではなく、レイヤ構造、依存関係、データフロー、UIスレッドモデル等との紐付けを書く。

  例：

  | QA \ Candidate | A（Layered Monolith） | B（DDD Lite Monolith） | コメント（重要な理由・具体策） |
  |----------------|------------------------|-------------------------|----------------------------------|
  | QA-001         | ◎                      | ○                       | Aは処理経路が短く、インフラも単純。Bは抽象化層が1段増えるが、I/O主体で影響は小さい。 |
  | QA-003         | ○                      | ◎                       | BはDomain層を独立させ、リポジトリ経由に限定するため変更影響範囲を狭く保てる。Aは層分離のみでルールが緩いと散らばりやすい。 |
  | ...            | ...                    | ...                     | ...                              |

  > 重要：
  > - コメントは「どのレイヤ／どのコンポーネント／どの設計ルール」により QA を満たすか、  
  >   1〜2 行で必ず書くこと（抽象的NG）。
  > - UIのレスポンス性（フリーズ対策）などは、Performance / Usability の評価時に  
  >   「ワーカースレッドを用いる」「進捗表示を行う」など具体策を示す。

  ### 4.2 リスクとトレードオフ

  各候補ごとに、主要なリスクとトレードオフを整理する。

  #### Candidate A
  - **強み**
    - …
  - **弱み / リスク**
    - …
  - **向いているケース / 向いていないケース**
    - …
  - **将来の機能拡張シナリオに対する見通し**
    - 要件凍結として扱っている場合でも、「どのような拡張要求が来たら再評価が必要になるか」を 1〜2 行で書く。

  #### Candidate B
  - 同様に記述。

  > ポイント：
  > - 「小規模だから大丈夫」といった楽観的な前提に逃げず、
  >   将来の典型的な拡張（機能追加／外部サービス増加／組織変更）に対する見通しを書くこと。
  > - データフロー・DBスキーマ・サービス分割など、  
  >   どこが将来のボトルネック／負債になり得るかをはっきり書く。

  ---

  ## 5. Recommended Architecture（推奨アーキテクチャ）

  ### 5.1 採用するアーキテクチャ

  - 採用候補：Candidate <X>（<名前>）
  - 採用理由（箇条書き）：
    - **主要品質特性（QA-xxx）に対する適合性**が最も高い／バランスがよいこと
    - **既存システム / チームスキルとの整合性**（現実に実装・運用できるか）
    - **将来の拡張性**（どのレベルまでなら大きなリファクタリングなしに対応できるか）
    - **データフローと Single Source of Truth** の観点で、一貫性を保ちやすいこと
    - UIアーキテクチャの方針（MVC/MVP等）が、選択したアプリケーションアーキテクチャと整合していること

  ### 5.2 選択しなかった候補と理由

  - Candidate Y を採用しない理由
    - 長所
    - それでも優先度が下がる理由（複雑性、コスト、過剰設計、チームスキルとのギャップ 等）
  - ADR では、ここで書いた内容を凝縮して「Alternatives」に載せる。

  > 注意：
  > - 「UIがそんなに複雑ではないので MVC を採用しない」といった表現は  
  >   **UIパターンの採否**として書く場合にのみ使用し、  
  >   アプリケーションアーキテクチャの比較理由としては使わないこと。

  ---

  ## 6. Impact & Risks（影響とリスク）

  以下の観点を必ず含める：

  - **開発コストへの影響**
    - 初期実装コスト（学習コスト、ボイラープレートの量）
    - テスト設計・テスト自動化のコスト
  - **運用コストへの影響**
    - インフラ構成の複雑さ（モノリス vs 分散）
    - 障害対応の難易度
    - ログ収集・監視・バックアップの仕組み
  - **組織・プロセスへの影響**
    - チームサイズと役割分担（フロント / バック / APP / INFRA）
    - 必要となるスキルセット
    - 既存プロセス（リリースフロー、運用手順）との整合
  - **技術的負債になりうるポイント**
    - ビジネスロジックの散在（UI・Infrastructure への漏れ）
    - 層間の密結合（特に Application ↔ Infrastructure）
    - データフローが曖昧な部分（CSV vs DB の整合性など）
  - **リスク軽減策の概要**
    - コーディング規約／レイヤ間の依存ルールの明文化
    - リポジトリパターンやインターフェースによる抽象化の導入
    - 定期的なアーキテクチャレビュー
    - 「どのような変更要求が来たらアーキテクチャの再評価を行うか」のトリガー定義

  ---

  ## 7. Inputs for ADR（ADR 作成のための要約）

  ADR コマンド（adr-create.md）に渡すための **要約情報** を記載する。

  > ここは「設計書のダンプ」ではなく、ADR向けに**圧縮したサマリ**を書くこと。  
  > 各項目は 3〜6 行程度を目安とする。

  - **Problem（問題）**
    - どのような要求・制約・前提（技術／運用／組織／データフロー）のもとで
      アーキテクチャを決める必要があるかを簡潔にまとめる。
  - **Decision（決定）**
    - 採用するアーキテクチャ（Candidate X, 名前）と、その一文要約。
    - 例：「モジュラモノリス構成のレイヤードアーキテクチャを採用し、Presentation / Application / Domain / Infrastructure の4層で構成する」など。
  - **Alternatives（代替案）**
    - 検討した候補と、採用しなかった理由を箇条書きで要約。
    - ここでは詳細ではなく「なぜ退けたか」が一目で分かるレベルに抑える。
  - **Rationale（根拠）**
    - 選択したアーキテクチャが最も合理的と判断された理由を、
      主要な品質特性（QA-xxx）との関係で 3〜5 行程度にまとめる。
  - **Consequences（結果・影響）**
    - ポジティブ / ネガティブ両面の影響を簡潔に列挙。
    - 特に、将来の拡張時に必要となるリファクタリングや見直しポイントも含める。

  `adr-create.md` では、この 7 章の内容をそのまま ADR の各セクションに流用してよいが、  
  必要に応じてさらに凝縮・整形すること。

  ---

  ## 禁止事項

  - `docs/requirements/02_system-requirements.md` の内容や構造を勝手に変更しないこと。
  - STK / REQ-F / REQ-NF の ID を再定義・再採番しないこと。
  - 「アーキテクチャ検討」と「最終決定（ADR）」を混同しないこと。  
    本ドキュメントは **検討結果の記録** にとどめ、  
    最終決定は ADR で行う前提とする。
  - **UI アーキテクチャ（MVC / MVP / MVVM 等）を、アプリケーションアーキテクチャ候補そのものとして Candidate に並べないこと。**  
    必要であれば、「各 Candidate の中の Presentation 層の設計方針」としてのみ扱う。

   ```

6. `adr-create.md`
   - 新しい設計判断について `ADR/ADR-<番号>-<タイトル>.md` を生成。

   ```markdown
   # ADR（Architecture Decision Record）作成

   新しい設計判断またはアーキテクチャ判断について、
   ADR/ADR-<番号>-<タイトル>.md を生成する。

   ## テンプレ
   - 背景
   - 判断
   - 選択肢
   - メリット/デメリット
   - 根拠
   - トレードオフ
   - 状態（Accepted / Deprecated / Superseded）

   docs/requirements および docs/design を参照し整合性を保つ。
   ```

7. `design-from-requirements.md`
   - 要件定義から `docs/design/<設計対象>.md` を生成（UI/ドメイン/IF設計）。

   ```markdown
   # 設計書生成（UI / ドメイン / IF 設計）

   docs/requirements/02_system-requirements.md を参照し、
   docs/design/<設計対象>.md を生成する。

   必要に応じて:
   - 図（Mermaid）
   - シーケンス図
   - データフロー
   - クラス構成
   を含める。
   ```

8. `create-plan.md`
   - 機能単位の実装計画 `plans/feature-<機能名>.md` を生成。

   ```markdown
   # 実装計画（プラン）作成

   対象機能 <機能名> のタスク分解を行い、
   plans/feature-<機能名>.md を作成する Markdown を生成する。

   ## 出力構成
   - 背景
   - スコープ（含める/含めない）
   - タスク一覧（1〜2時間粒度）
   - リスク/懸念点
   - 依存関係
   ```

9. `implement-file.md`
   - 要件 + プランから `src/<ファイル>.py` と対応する `tests/` を生成または更新。

   ```markdown
   # コード実装（仕様 + プラン → ファイル生成）

   docs/requirements/02_system-requirements.md と
   plans/feature-<機能名>.md を参照し、
   src/<ファイル>.py を生成または更新する。

   ## 制約
   - 型アノテーション必須
   - ruff / mypy / pytest でエラーなし
   - 必要に応じて tests/ に pytest テストも生成
   ```

10. `quality-fix.md`
   - `ruff` / `mypy` / `pytest` を用いた品質チェックと自動修正。

   ```markdown
   # 品質チェック（ruff / mypy / pytest / lizard）

   以下を順に実行できる形式で案内し、必要ならコード修正も行う。
   1. ruff の lint チェック
   2. mypy の型チェック
   3. pytest のテスト実行
   4. エラー内容の解析と修正案の提示
   5. 必要に応じてコードへパッチを適用

   対象:
   - src/ 配下の Python ファイル
   - tests/ 配下のテストコード
   ```

11. `refactor.md`
   - 既存コードを責務分割・命名改善・重複削除などの方針でリファクタ。

   ```markdown
   # リファクタ（責務分割・命名改善・整理）

   src/<ファイル>.py を読み込み、
   以下を基準にリファクタ案を生成し、必要に応じて修正を適用する。

   - 単一責務
   - 関数分割
   - 命名改善
   - 循環依存の解消
   - 重複コード削除
   - テストの整合性確保
   ```

12. `release-notes.md`
   - Git のコミット履歴/差分から `docs/release-notes/release-<version>.md` 用のリリースノートを生成。

   ````markdown
   # リリースノート自動生成コマンド

   ## 目的
   - 直近の変更内容（コミットや差分）をもとに、リリースノートを自動生成する。
   - docs/release-notes/release-<version>.md に貼り付け可能な形式で出力する。

   ## 前提
   - default ブランチ: main
   - 対象範囲: 直近のタグ〜HEAD または 指定範囲

   ## 入力例
   - 対象バージョン: v1.2.0
   - 対象範囲: 直近タグ〜現在HEAD、もしくは `git diff` 範囲

   ## 手順
   1. git のコミット履歴または diff を取得する。
   2. 変更内容をカテゴリ別に分類する。
      - Added
      - Changed
      - Fixed
      - Removed
      - Deprecated
      - Security
   3. docs/release-notes/release-<version>.md 用の Markdown を生成する。

   ## 出力フォーマット例

   ```markdown
   # Release v<version> - <YYYY-MM-DD>

   ## Summary
   - <1〜3行で概要>

   ## Added
   - ...

   ## Changed
   - ...

   ## Fixed
   - ...

   ## Known Issues
   - ...
   ```
   ````


13. `ci-cd-setup.md`
   - プロジェクト構成に基づき、`Jenkinsfile` と `.github/workflows/ci.yml` を生成。

   ```markdown
   # CI/CD 設定コマンド（Jenkinsfile / GitHub Actions）

   ## 目的
   - プロジェクトの CI/CD 設定ファイル（Jenkinsfile, GitHub Actions Workflow）を
     プロジェクト方針に合わせて自動生成する。

   ## 前提
   - プロジェクトは Python（uv）を利用
   - ruff / mypy / pytest / lizard を使った品質チェックを CI で回す
   - main ブランチへの push / PR をトリガーとする

   ## 手順（共通）

   1. プロジェクトルート構成（src, tests, uv, ruff, mypy 設定）を確認する。
   2. Jenkins 用の `Jenkinsfile`（パイプライン）を生成する。
   3. GitHub Actions 用の `.github/workflows/ci.yml` を生成する。
   4. どのツールで何を行うかをコメントとして明記する。

   ## Jenkinsfile の要件

   - パイプライン構成:
     - Checkout
     - Python / uv セットアップ
     - 依存関係インストール
     - ruff 実行
     - mypy 実行
     - lizard 実行
     - pytest 実行
   - main ブランチ向けのパイプライン定義
   - 将来の拡張（デプロイステージ）のためのコメントを残すこと

   ## GitHub Actions ci.yml の要件

   - トリガー:
     - push: main
     - pull_request: main
   - ジョブ:
     - ubuntu-latest で実行
     - Python バージョン 3.x
     - uv インストール
     - 依存関係インストール
     - ruff / mypy / pytest 実行
     - キャッシュ（pip or uv）を可能なら利用

   ## 出力

   - プロジェクトルートに以下のファイルを生成する Markdown or パッチを出力する:
     - `Jenkinsfile`
     - `.github/workflows/ci.yml`
   - 各ステップにコメントを付け、読み手が CI/CD の流れを理解できるようにする。
   ```

