# 1. プロジェクト作成（Claude Code 前提）

## 1.1 目的
- Claude Code と MCP（Context7 / filesystem / git / exec / text-analysis）を前提にした開発プロジェクトの初期セットアップを標準化する。
- どのプロジェクトでも本章の手順を完了すれば、後続フェーズ（要件定義 → 設計 → ADR → 実装 → テスト）を再現性と品質を維持しながら進められる状態にする。

---

## 1.2 手順概要

1. プロジェクトディレクトリの作成  
2. Python 仮想環境（uv）＋ 基本品質ツール（ruff / mypy / pytest）の導入  
3. Git 初期化（main ブランチを確定）  
4. ベースディレクトリ構成の作成＋ src-layout への統一  
5. Claude Code 初期化  
6. ベース MCP の追加（Context7 / filesystem / git / exec / text-analysis）  
7. Claude.md（プロジェクト記憶）の作成  
8. カスタムコマンド（`.claude/commands/*.md`）の作成  

---

## 1.3 プロジェクトディレクトリ作成

```sh
mkdir <project>
cd <project>
```

- `<project>` はリポジトリ名・Claude Code の Project name と一致させる。

---

## 1.4 仮想環境の追加（Python / uv）

本プロジェクトでは **src-layout（src/ 配下にコードを配置）** を必須とするため、  
uv init が生成する main.py は後で移動する。

```sh
uv init .
uv add --dev ruff mypy pytest lizard
```

- `uv init .` で `pyproject.toml` と仮想環境を作成する。
- `ruff` と `mypy` は標準の品質チェックツールとして必須とする。

### なぜ pytest をこの段階で入れるのか？
- **TDD / BDD を初期から可能にするため**
- CI/CD 構成（GitHub Actions / Jenkins）と整合性が取れるため
- Claude Code の `implement-file.md` でテスト自動生成を行うため

---

## 1.5 Git 初期化

```sh
git init .
git branch -M main
```

- `.gitignore` は uv + Python 専用の推奨設定を使用する。
- main ブランチは常に「動作保証状態」とし、CI/CD はこの前提で構成する。

---

## 1.6 ベースディレクトリ構成

（src-layout + ドキュメントテンプレ構造と完全整合）
uv init により `main.py` がプロジェクト直下に生成されるため、**src-layout** に統一する。

```sh
mkdir -p src tests
mkdir -p docs/requirements docs/design
mkdir -p ADR
mkdir -p plans
mkdir -p docs/release-notes
mkdir -p .github/workflows
mkdir -p .claude/commands

mv main.py src/main.py
```

### なぜ src-layout が必須なのか？
- Python の推奨構造（PyPA 標準）
- CI（pytest / ruff / mypy）が安定する
- Claude Code がファイル参照する際のパスブレを防止
- 将来的なパッケージ化にも対応可能
- テストと実装のディレクトリを明確にセパレートするため

### ディレクトリごとの役割（後工程との整合性を明記）

| ディレクトリ | 役割 |
|--------------|------|
| src/ | アプリケーション本体（すべてのコードはここに置く） |
| tests/ | pytest による自動テスト群 |
| docs/requirements/ | 01, 02, 03, 04 の要求/要件/文脈テンプレ文書 |
| docs/design/ | 設計書（UI/ドメイン/インターフェース） |
| ADR/ | Architecture Decision Record（設計判断の履歴） |
| plans/ | 機能別実装計画（フィーチャー分解） |
| docs/release-notes/ | リリースノート自動生成の保管場所 |
| .github/workflows/ | GitHub Actions（CI/CD） |
| .claude/commands/ | Claude Code のカスタムコマンド定義 |

### 注意（見出し構造保護との整合性）
docs/requirements の文書（01, 02）は  
**Claude.md により見出し構造固定を強制できる前提**  
で運営される。

---

## 1.7 Claude Code 初期化

Claude Code 上で当該プロジェクトを開き、以下を実行する。

```claude
/init
```

### この工程の目的
- この瞬間から、このディレクトリが **Claude Code にとっての正式な “Project context”** になる。
- 以降の会話・生成物はすべて **Project memory（Claude.md）に基づく** 振る舞いに変わる。
- Claude がプロジェクト単位で「仕様 → 設計 → ADR → コード → テスト」を一貫処理できる環境がここで初期化される。

### 注意（絶対遵守）
- `/init` 前にファイル生成を依頼すると、Claude が文脈を誤認してテンプレ構造が壊れる可能性がある。
- `/init` は **MCP 導入より先に実行する**。  
  （MCP がプロジェクトに紐づかない不整合を防止）

---

## 1.8 MCP 標準構成（Claude Code プロジェクト用）  
（Context7 / filesystem  — scope=project）

### 1.8.1 目的

本プロジェクトの開発フロー（要件 → 設計 → ADR → 実装 → テスト）において、Claude Code が次の 2 つの能力を持つことを保証する：

| MCP 名（Claude 内名称） | パッケージ名（公式）                                  | 目的 |
|------------------------|------------------------------------------------------|------|
| filesystem             | @modelcontextprotocol/server-filesystem              | ファイル操作（生成・更新・削除・探索） |
| context7               | @upstash/context7-mcp                                | ドキュメント/API仕様参照（Upstash） |

※ modelcontextprotocol/* は MCP 公式 Reference Server。  
※ context7 は Upstash が提供する唯一の “AI対応ドキュメントレイヤ MCP” のため例外採用。


---

### 1.8.2 スコープと前提（ここを間違えると全て壊れる）

Claude CLI の `-s` / `--scope` は **「スコープ指定」** であり、  
**プロジェクト名ではない**。

利用可能なスコープは以下のみ：

- `local`
- `user`
- `project`
- `dynamic`
- `enterprise`

本プロジェクトでは、  
**「このリポジトリ専用の MCP 構成」** を作るため、  
すべて **`-s project`（project scope）** で登録する。

> `-s profit_trace` のように **任意の文字列を指定することはできない**。  
> `Invalid scope: xxx` エラーになるのは仕様通り。

---

### 1.8.3 MCP 追加手順（必須 2 種）

Claude Code は OS によって MCP サーバを起動する方法が異なる。  
特に **Windows 版 Claude Code は `npx` を直接呼び出せない仕様**のため、  
`cmd /c` を前置して **必ず cmd.exe 経由で npx を起動させる必要がある**。

| OS | npx 実行可否 | 必要な対処 | 例 |
|----|--------------|------------|-----|
| **Windows** | ✗（Claude Code では直接不可） | `cmd /c` を前置する | `cmd /c npx @modelcontextprotocol/server-filesystem` |
| **Linux / macOS** | ○（そのまま動作） | 対処不要 | `npx @modelcontextprotocol/server-filesystem` |

---

#### 共通構文

```sh
claude mcp add <name> -s project -- <commandOrUrl>
```

- `<name>`: Claude から見える MCP 名（例: `context7`, `filesystem` など）
- `-s project`: 「このプロジェクト用の MCP」として登録する
- `<commandOrUrl>`: MCP サーバを起動するためのコマンド or URL  
  （各 MCP ごとに異なる。公式 README の指示に従うこと）

---

#### 1.8.3.1 Context7 MCP（ドキュメント参照）

#### Linux / macOS

```sh
claude mcp add context7 -s project -- npx @upstash/context7-mcp --api-key YOUR_API_KEY
```

#### Windows
Windowsの場合は`--api-key`を認識しないので、まずは下記を記載し、直接.mcp.jsonファイルを編集する

```sh
claude mcp add context7 -s project -- cmd /c npx @upstash/context7-mcp
```
[https://context7.com/](https://context7.com/)からAPI KEYを取得する
```json
"context7": {
      "type": "stdio",
      "command": "cmd",
      "args": [
        "/c",
        "npx",
        "@upstash/context7-mcp",
        "--api-key",
        "XXXXX"
      ],
      "env": {}
    }
```

用途：
- Python / Node / Rust / C# など公式ドキュメント参照  
- API 仕様の正確な参照  
- 設計判断の精度向上  
- ADR の合理性裏付け

---

#### 1.8.3.2 filesystem MCP（ファイル操作）

#### Linux / macOS

```sh
claude mcp add filesystem -s project -- npx @modelcontextprotocol/server-filesystem
```

#### Windows  
（実際に失敗していた部分。原因は Windows 版 Claude Code では npx が直接動かないため）

```sh
claude mcp add filesystem -s project -- cmd /c npx @modelcontextprotocol/server-filesystem
```

用途：
- `docs/requirements/` や `docs/design/`、`ADR/` のファイル自動生成
- `src/` のコード生成・更新
- 差分パッチ適用

---

### 1.8.4 MCP 設定確認（必須）

```sh
claude mcp list
```

以下 2 種が揃っていれば正しく導入されている：

- context7
- filesystem

1 つでも欠けていれば、該当 MCP の `<commandOrUrl>` 指定が誤っている可能性が高い。

---

### 1.8.5 MCP 導入後の初期動作チェック

#### filesystem の動作確認

```claude
docs/requirements/test.md を作成し、
内容を「MCP OK」という 1 行だけにしてください。
```

#### context7 の動作確認

```claude
Python の requests ライブラリの最新仕様を context7 で参照し、
要点を箇条書きでまとめてください。use context7
```

---

### 1.8.6 MCP フェーズの終了条件

以下の条件をすべて満たした場合、このフェーズを完了とする：

- `claude mcp list` に 2 種（context7 / filesystem ）が表示されている
- 各 MCP で最低 1 回の操作（ファイル操作 / 仕様参照）が成功している
- Claude Code が  
  「要件整理 → 要件定義 → 設計 → ADR → 実装 → テスト」  
  を実行可能な最低限の基盤を満たしている

---

## 1.9 ベースメモリ（Claude.md）作成

プロジェクトの前提・ルール・構造をまとめた `Claude.md` をプロジェクトルートに作成する。

テンプレート例：

````markdown
# Project memory

このファイルは Claude Code の振る舞いを制御するための **プロジェクト仕様** である。  
本プロジェクトにおいて Claude は、ここに定められた規則を常に守らなければならない。

---

# 1. Project Overview
- Project name: <project>
- Purpose: <1〜3行>
- Primary language: Python (uv)
- Entrypoint: src/main.py

---

# 2. Document Templates (Structural Integrity Rules)

以下のドキュメントは **見出し構造が完全固定** であり、  
Claude は、**追記以外の変更（削除 / 並び替え / 統合 / 分解 / 改名）を一切行ってはならない**。

## 2.1 01_stakeholder-needs.md の構造（固定）
```
# 01. Stakeholder Needs
## 1. Purpose
## 2. Scope
### 2.1 In Scope
### 2.2 Out of Scope
## 3. Stakeholder List
## 4. Stakeholder Needs
### 4.x <Stakeholder Name>
#### STK-xxx: <Title>
## 5. Constraints
## 6. Assumptions
## 7. Open Questions
## 8. Appendix
```

## 2.2 02_system-requirements.md の構造（固定）
```
# 02. System Requirements
## 1. Overview
## 2. Definitions
## 3. Functional Requirements
### 3.1 構成方針
### 3.2 要件一覧
#### REQ-F-xxx: <Title>
## 4. Non-Functional Requirements
#### REQ-NF-xxx: <Title>
## 5. Constraints
## 6. Open Questions
## 7. Appendix
```

### 【重要】
Claude がこれらに触れるときは、  
**・追記は許可  
・既存見出しの削除は禁止  
・既存見出しの名称変更は禁止  
・既存見出しの階層変更は禁止  
・新しい章の追加は禁止（Appendix 内は可）  
・内容の書き換えは Claude が明確な理由（要件反映）がある場合のみ許可**  
とする。

---

# 3. Repository Layout
- src/
- tests/
- docs/requirements/
- docs/design/
- ADR/
- plans/
- docs/release-notes/

---

# 4. Process Rules
- 開発フロー：要件 → 設計 → ADR → 実装 → テスト
- 要件・設計の前に、必ず docs/requirements を参照する
- 重要な判断は必ず ADR に記録する
- main ブランチは常に動作保証状態とする

---

# 5. Claude Usage Policy (行動規範)

Claude は以下の行動規範に従う。

## 5.1 テンプレ遵守ルール（最重要）
- 固定テンプレ構造を **絶対に変更してはならない**
- 見出し構造を “省略して要約” する行為も禁止
- 「別の構造のほうがよい」などの提案は Appendix へ書くが、構造自体は変えない
- 要件追加は **既存の適切な見出しの下に追記** のみ許可

## 5.2 ドキュメント編集ルール
- 編集前に該当 doc の全文を読み込む
- 差分パッチ形式での変更を優先する
- 変更理由を説明する（例：STK-xxx との整合性）

## 5.3 技術ドキュメントの一貫性
- STK-xxx → REQ-F/REQ-NF のトレーサビリティを維持する  
- 不確実性は Open Questions に送る（埋めない）

---

# 6. MCP Usage Rules
- context7：公式ドキュメント参照に使用  
- filesystem：Markdown ドキュメントの自動編集  
---

# 7. 禁止事項
Claude は **以下の行為を禁止** される。

- ドキュメント構造（見出し）の変更  
- 章タイトルの変更  
- 階層構造の変更  
- 分割/統合による章の再構成  
- 任意の新章追加（Appendix 以外）  
- テンプレの自動要約や省略  

---

# 8. Development Principles
- 情報不足は “補完しない”。Open Questions に送る。
- 数値の省略禁止（例：「高速」→ “500ms 以下” 提案）
- 曖昧表現禁止

---

# 9. Appendix
必要なら補足を追加する。
````

---

## 1.10 カスタムコマンド追加（`.claude/commands`）

### 1.10.1 目的

- Claude Code のコマンドパレットから、頻出の作業（要件整理・設計生成・プラン作成・実装・品質チェック・リリースノート作成・CI設定）を一貫した形で呼び出せるようにする。
- チーム全体で同じプロンプト・同じフローを共有し、再現性のある開発プロセスを確立する。

---

### 1.10.2 カスタムコマンド作成方法

カスタムコマンドは **`.claude/commands/*.md`** として保存する。

作成依頼例：

```claude
要求整理テンプレートを
.claude/commands/requirements-draft.md に作成してください。
```

Claude 再起動後、`requirements-draft` コマンドとして利用可能になる。

---

### 1.10.3 ベースコマンド一覧

初期セットアップで、少なくとも以下のコマンドを用意する。

#### 必須（要件〜実装〜品質）

1. `requirements-draft.md`  
   - ヒアリングメモ → `docs/requirements/01_stakeholder-needs.md` のドラフト生成。
    ```markdown
    # 要求整理（ヒアリングメモ → 01_stakeholder-needs.md）
    以下のヒアリングメモを、固定テンプレート構造にマッピングし  
    docs/requirements/01_stakeholder-needs.md を生成すること。

    **見出し構造は絶対に変更してはならない。**

    ---

    ## 【出力するファイル構造】

    # 01. Stakeholder Needs

    ## 1. Purpose
    （ヒアリング内容から目的を抽出し、1〜3 行で要約する）

    ## 2. Scope
    ### 2.1 In Scope
    （対象とする範囲を列挙する）
    ### 2.2 Out of Scope
    （対象外の範囲があれば補完する）

    ## 3. Stakeholder List
    | ID | Stakeholder | 役割 / 関心事 |
    |----|-------------|----------------|
    （ヒアリング内容から抽出し、STKH-xxx として列挙）

    ## 4. Stakeholder Needs
    ステークホルダー単位で要求を分類し、以下の構造に従って必ず記述する。

    ### 4.x <Stakeholder Name>
    #### STK-xxx: <要求タイトル>
    **概要**  
    （要求の要点を 1 行で要約）

    **詳細**  
    - ユースケース
    - 背景
    - 懸念・不満点
    - 必要とされる理由  
    （メモに足りない場合は質問として Open Questions に送る）

    **受入条件**  
    - 条件1
    - 条件2

    **関連ステークホルダー**  
    - STKH-xxx

    **優先度**  
    MUST / SHOULD / COULD / WON’T より選択

    ## 5. Constraints
    - 技術的制約
    - 運用制約
    - 外部依存  
    （ヒアリングに無い場合は空欄ではなく “情報不足、要確認” と記述）

    ## 6. Assumptions
    （前提条件を抽出し、不足がある場合は “要確認（理由）” と明記）

    ## 7. Open Questions
    不明点や曖昧な部分を必ずここに列挙すること。  
    - 質問内容  
    - 誰に確認すべきか  
    - 影響範囲  

    ## 8. Appendix
    - 元ヒアリングメモ要約
    - 関連図や補足があれば記載
    ---

    ## 【入力】
    <<<ヒアリングメモ>>>
    ```
2. `requirements-refine.md`
   - `01_stakeholder-needs.md`の質問を解消

   ```markdown
    # 要求クリーニング（Open Questions 解消 → 01_stakeholder-needs.md 更新）

    ## 目的:
    - docs/requirements/01_stakeholder-needs.md の **7. Open Questions** を解消し、
      要求を完成状態（凍結）にする。
    - 既存テンプレート構造を絶対に変更しない。
    - 解消された質問内容は、対応するセクション（Purpose / Scope / Needs / Constraints など）に反映させる。

    ---

    ## 入力
    - 回答したい Open Questions の一覧  
    - 回答内容（ユーザーが入力）

    例:
    <<<OpenQuestions回答>>>

    ---

    ## 出力要件

    1. docs/requirements/01_stakeholder-needs.md を再生成する。  
    2. 見出し構造は **以下の固定構造を絶対に変更しない**  

      - # 01. Stakeholder Needs  
      - 1. Purpose  
      - 2. Scope  
        - 2.1 In Scope  
        - 2.2 Out of Scope  
      - 3. Stakeholder List  
      - 4. Stakeholder Needs  
      - 5. Constraints  
      - 6. Assumptions  
      - 7. Open Questions  
      - 8. Appendix  

    3. 質問に回答された箇所は適切なセクションに反映する。  
    4. 解消された Open Questions は削除する。  
    5. まだ不足があれば、新たな Open Questions を追加する。  
    6. すべての質問が解消された場合、7 は `None` のみとする。

    ---

    ## 禁止事項
    - 見出し構造の追加・削除・並び替え
    - 01_stakeholder-needs.md に存在しない要素の追加
    - STK-ID や STKH-ID の再採番

   ```


3. `requirements-definition.md`  
   - ステークホルダー要求 → `docs/requirements/02_system-requirements.md` の要件定義書生成。
    ```markdown
    # 要件定義生成（01_stakeholder-needs.md → 02_system-requirements.md）

    docs/requirements/01_stakeholder-needs.md を参照し、  
    以下に示す **完全固定テンプレート構造** に基づいて  
    docs/requirements/02_system-requirements.md を生成すること。

    **見出し構造は絶対に変更してはならない。**

    あいまい・不足・矛盾がある場合は  
    「6. Open Questions」で必ず指摘し、埋めようとしないこと。

    ---

    ## 【出力するファイル構造】

    # 02. System Requirements

    ## 1. Overview（概要）
    - システムの目的  
    - 01_stakeholder-needs.md の Purpose との整合性を確認して要約  
    - システムが何を解決するかを 3〜5 行でまとめる  

    ---

    ## 2. Definitions（定義）
    要求から登場する重要語句を整理し、  
    用語集（03_glossary.md）で定義する前の仮リストとして記述する。

    | Term | Definition | Related Requirements |
    |------|------------|----------------------|
    | <用語> | <定義> | STK-xxx |

    ---

    ## 3. Functional Requirements（機能要件）

    ### 3.1 構成方針
    - 要求（STK-xxx）から導出される機能要件を  
      **REQ-F-XXX（機能ID）** 形式で記述すること。
    - 各要件は **受入条件** を必ず持つ。
    - 必ず **関連するステークホルダー要求（STK-xxx）** と紐付ける。

    ---

    ### 3.2 要件一覧

    #### REQ-F-xxx: <機能要件タイトル>
    **概要**  
    要求から導出した機能の要点（1 行）

    **詳細**  
    - システムが実行すべき動作  
    - 入力 / 出力  
    - 例外処理（可能な範囲）  
    - 条件分岐に必要な情報  

    **受入条件（明確な検証可能条件）**  
    - 条件1  
    - 条件2  

    **関連要求**  
    - STK-xxx, STK-yyy  

    **備考（必要なら）**  
    （仕様で補足が必要な点）

    ---

    ## 4. Non-Functional Requirements（非機能要件）

    非機能要件は **REQ-NF-XXX** の形式で記述する。

    ### 4.1 パフォーマンス（例）
    #### REQ-NF-001: <タイトル>
    - 詳細
    - 数値基準（曖昧な場合は提案を行う）

    ### 4.2 セキュリティ
    （同形式）

    ### 4.3 保守性
    （同形式）

    ### 4.4 運用性
    （同形式）

    ### 4.5 可用性
    （同形式）

    ※ 非機能要件カテゴリは必要に応じて追加してよいが、  
      **REQ-NF の ID体系は必ず統一すること。**

    ---

    ## 5. Constraints（制約）
    01_stakeholder-needs.md の Constraints を以下に継承し、不足があれば補完する。

    - <制約1>  
    - <制約2>  

    曖昧なものがあれば **“情報不足（理由）”** と明記する。

    ---

    ## 6. Open Questions（要確認事項）
    要求から要件化できなかった曖昧点や不足情報は  
    必ずここにまとめて列挙する。

    | 質問 | 理由 / 影響範囲 | 誰に確認すべきか |
    |------|----------------|-------------------|
    | <例> この機能は管理者だけか？ | 認可要件に影響 | PO |

    要件定義フェーズを進める前に解消すべき点をクリアにする。

    ---

    ## 7. Appendix
    - 要求 → 要件のマッピング表（Claude が自動生成してよい）
    - メモ・補足  

    ---

    ## 【入力】
    docs/requirements/01_stakeholder-needs.md の内容全体を参照すること。
    必要であれば context7 を利用して関連ドキュメントを参照してよい。
    ```

4. `adr-create.md`  
   - 新しい設計判断について `ADR/ADR-<番号>-<タイトル>.md` を生成。
    ```markdown
    # ADR（Architecture Decision Record）作成

    新しい設計判断またはアーキテクチャ判断について、
    ADR/ADR-<番号>-<タイトル>.md を生成する。

    ## テンプレ
    - 背景
    - 判断
    - 選択肢
    - メリット/デメリット
    - 根拠
    - トレードオフ
    - 状態（Accepted / Deprecated / Superseded）

    docs/requirements および docs/design を参照し整合性を保つ。
    ```

5. `design-from-requirements.md`  
   - 要件定義から `docs/design/<設計対象>.md` を生成（UI/ドメイン/IF設計）。
    ```markdown
    # 設計書生成（UI / ドメイン / IF 設計）

    docs/requirements/02_system-requirements.md を参照し、
    docs/design/<設計対象>.md を生成する。

    必要に応じて:
    - 図（Mermaid）
    - シーケンス図
    - データフロー
    - クラス構成
    を含める。
    ```

6. `create-plan.md`  
   - 機能単位の実装計画 `plans/feature-<機能名>.md` を生成。
   ```markdown
    # 実装計画（プラン）作成

    対象機能 <機能名> のタスク分解を行い、
    plans/feature-<機能名>.md を作成する Markdown を生成する。

    ## 出力構成
    - 背景
    - スコープ（含める/含めない）
    - タスク一覧（1〜2時間粒度）
    - リスク/懸念点
    - 依存関係
    ```

7. `implement-file.md`  
   - 要件 + プランから `src/<ファイル>.py` と対応する `tests/` を生成または更新。
    ```markdown
    # コード実装（仕様 + プラン → ファイル生成）

    docs/requirements/02_system-requirements.md と
    plans/feature-<機能名>.md を参照し、
    src/<ファイル>.py を生成または更新する。

    ## 制約
    - 型アノテーション必須
    - ruff / mypy / pytest でエラーなし
    - 必要に応じて tests/ に pytest テストも生成
    ```

8. `quality-fix.md`  
   - `ruff` / `mypy` / `pytest` を用いた品質チェックと自動修正。
   ```markdown
    # 品質チェック（ruff / mypy / pytest / lizard）

    以下を順に実行できる形式で案内し、必要ならコード修正も行う。

    1. ruff の lint チェック
    2. mypy の型チェック
    3. pytest のテスト実行
    4. エラー内容の解析と修正案の提示
    5. 必要に応じてコードへパッチを適用

    対象:
    - src/ 配下の Python ファイル
    - tests/ 配下のテストコード
    ```

9. `refactor.md`  
    - 既存コードを責務分割・命名改善・重複削除などの方針でリファクタ。
    ```markdown
    # リファクタ（責務分割・命名改善・整理）

    src/<ファイル>.py を読み込み、
    以下を基準にリファクタ案を生成し、必要に応じて修正を適用する。

    - 単一責務
    - 関数分割
    - 命名改善
    - 循環依存の解消
    - 重複コード削除
    - テストの整合性確保
    ```

10. `release-notes.md`  
    - Git のコミット履歴/差分から `docs/release-notes/release-<version>.md` 用のリリースノートを生成。
    ```markdown
    # リリースノート自動生成コマンド

    目的:
    - 直近の変更内容（コミットや差分）をもとに、リリースノートを自動生成する。
    - docs/release-notes/release-<version>.md に貼り付け可能な形式で出力する。

    ## 前提
    - default ブランチ: main
    - 対象範囲: 直近のタグ〜HEAD または 指定範囲

    ## 入力例
    - 対象バージョン: v1.2.0
    - 対象範囲: 直近タグ〜現在HEAD、もしくは `git diff` 範囲

    ## 手順
    1. git のコミット履歴または diff を取得する。
    2. 変更内容をカテゴリ別に分類する。
    - Added
    - Changed
    - Fixed
    - Removed
    - Deprecated
    - Security
    3. docs/release-notes/release-<version>.md 用の Markdown を生成する。

    ## 出力フォーマット例

    ```markdown
    # Release v<version> - <YYYY-MM-DD>

    ## Summary
    - <1〜3行で概要>

    ## Added
    - ...

    ## Changed
    - ...

    ## Fixed
    - ...

    ## Known Issues
    - ...
    ```


11. `ci-cd-setup.md`  
    - プロジェクト構成に基づき、`Jenkinsfile` と `.github/workflows/ci.yml` を生成。

    ```markdown
    # CI/CD 設定コマンド（Jenkinsfile / GitHub Actions）

    ## 目的:
    - プロジェクトの CI/CD 設定ファイル（Jenkinsfile, GitHub Actions Workflow）を
    プロジェクト方針に合わせて自動生成する。

    ## 前提
    - プロジェクトは Python（uv）を利用
    - ruff / mypy / pytest / lizard を使った品質チェックを CI で回す
    - main ブランチへの push / PR をトリガーとする

    ## 手順（共通）

    1. プロジェクトルート構成（src, tests, uv, ruff, mypy 設定）を確認する。
    2. Jenkins 用の `Jenkinsfile`（パイプライン）を生成する。
    3. GitHub Actions 用の `.github/workflows/ci.yml` を生成する。
    4. どのツールで何を行うかをコメントとして明記する。

    ## Jenkinsfile の要件

    - パイプライン構成:
    - Checkout
    - Python / uv セットアップ
    - 依存関係インストール
    - ruff 実行
    - mypy 実行
    - lizard 実行
    - pytest 実行
    - main ブランチ向けのパイプライン定義
    - 将来の拡張（デプロイステージ）のためのコメントを残すこと

    ## GitHub Actions ci.yml の要件

    - トリガー:
    - push: main
    - pull_request: main
    - ジョブ:
    - ubuntu-latest で実行
    - Python バージョン 3.x
    - uv インストール
    - 依存関係インストール
    - ruff / mypy / pytest 実行
    - キャッシュ（pip or uv）を可能なら利用
    
    ## 出力

    - プロジェクトルートに以下のファイルを生成する Markdown or パッチを出力する:
    - `Jenkinsfile`
    - `.github/workflows/ci.yml`
    - 各ステップにコメントを付け、読み手が CI/CD の流れを理解できるようにする。

    ```

